# =============================================================================
# RustAssistant - CI/CD Pipeline
# =============================================================================
# Automated deployment of RustAssistant to Raspberry Pi via Tailscale
#
# Required Secrets:
#   - TAILSCALE_OAUTH_CLIENT_ID: Tailscale OAuth Client ID
#   - TAILSCALE_OAUTH_SECRET: Tailscale OAuth Secret
#   - PROD_TAILSCALE_IP: Production server Tailscale IP
#   - PROD_SSH_KEY: SSH private key for deployment
#   - PROD_SSH_USER: SSH username (default: actions)
#   - PROD_SSH_PORT: SSH port (default: 22)
#   - DOCKER_USERNAME: Docker Hub username
#   - DOCKER_TOKEN: Docker Hub access token
#   - DISCORD_WEBHOOK_ACTIONS: Discord webhook for CI/CD notifications
# =============================================================================

name: CI/CD Pipeline

on:
    push:
        branches: [main]
    pull_request:
        branches: [main]

env:
    CARGO_TERM_COLOR: always
    REGISTRY: docker.io
    IMAGE_NAME: nuniesmith/rustassistant

concurrency:
    group: ${{ github.workflow }}-${{ github.ref }}
    cancel-in-progress: false

jobs:
    # =========================================================================
    # Stage 1: Test and Lint (Fast - no coverage)
    # =========================================================================
    test-and-lint:
        name: üß™ Test and Lint
        runs-on: ubuntu-latest
        timeout-minutes: 20
        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4

            - name: üì£ Notify build started
              continue-on-error: true
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_ACTIONS }}
                  title: "üî® CI/CD Pipeline Started"
                  description: "Building RustAssistant"
                  status: started
                  include-repo-info: "true"

            - name: ü¶Ä Rust CI
              uses: nuniesmith/actions/.github/actions/rust-ci@main
              with:
                  toolchain: stable
                  run-fmt: "true"
                  run-clippy: "true"
                  run-tests: "true"
                  run-build: "true"
                  build-release: "true"
                  coverage: "false"

            - name: ‚úÖ Notify tests passed
              if: success()
              continue-on-error: true
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_ACTIONS }}
                  title: "‚úÖ Tests & Lint Passed"
                  description: "All tests passed successfully"
                  status: success

            - name: ‚ùå Notify tests failed
              if: failure()
              continue-on-error: true
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_ACTIONS }}
                  title: "‚ùå Tests Failed"
                  description: "CI tests failed. Check the logs for details."
                  status: failure
                  fields: '[{"name": "Workflow", "value": "[View Logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})", "inline": false}]'

    # =========================================================================
    # Stage 2: Build and Push Multi-Arch Docker Image (amd64 + arm64)
    # =========================================================================
    build-and-push:
        name: üê≥ Build and Push Docker Image
        needs: test-and-lint
        runs-on: ubuntu-latest
        timeout-minutes: 45
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4

            - name: Set up QEMU
              uses: docker/setup-qemu-action@v3

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v3

            - name: Log in to Docker Hub
              uses: docker/login-action@v3
              with:
                  username: ${{ secrets.DOCKER_USERNAME }}
                  password: ${{ secrets.DOCKER_TOKEN }}

            - name: Extract metadata
              id: meta
              uses: docker/metadata-action@v5
              with:
                  images: ${{ env.IMAGE_NAME }}
                  tags: |
                      type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
                      type=sha,prefix={{branch}}-

            - name: Build and push
              uses: docker/build-push-action@v5
              with:
                  context: .
                  file: docker/Dockerfile.web
                  platforms: linux/amd64,linux/arm64
                  push: true
                  tags: ${{ steps.meta.outputs.tags }}
                  labels: ${{ steps.meta.outputs.labels }}
                  cache-from: type=gha
                  cache-to: type=gha,mode=max

            - name: ‚úÖ Notify Docker build complete
              if: success()
              continue-on-error: true
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_ACTIONS }}
                  title: "üê≥ Docker Image Built"
                  description: "Multi-arch Docker images pushed to Docker Hub"
                  status: success
                  fields: '[{"name": "Image", "value": "${{ env.IMAGE_NAME }}:latest", "inline": true}, {"name": "Platforms", "value": "amd64, arm64 (Raspberry Pi)", "inline": true}]'

            - name: ‚ùå Notify Docker build failed
              if: failure()
              continue-on-error: true
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_ACTIONS }}
                  title: "‚ùå Docker Build Failed"
                  description: "Failed to build or push Docker images"
                  status: failure

    # =========================================================================
    # Stage 3: Deploy to Production (Raspberry Pi)
    # =========================================================================
    deploy:
        name: üöÄ Deploy to Raspberry Pi
        needs: build-and-push
        runs-on: ubuntu-latest
        timeout-minutes: 15
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4

            - name: üîå Connect to Tailscale
              uses: nuniesmith/actions/.github/actions/tailscale-connect@main
              with:
                  oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
                  oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
                  target-ip: ${{ secrets.PROD_TAILSCALE_IP }}
                  target-ssh-port: ${{ secrets.PROD_SSH_PORT || '22' }}

            - name: üöÄ Deploy via SSH
              id: deploy
              uses: nuniesmith/actions/.github/actions/ssh-deploy@main
              with:
                  host: ${{ secrets.PROD_TAILSCALE_IP }}
                  port: ${{ secrets.PROD_SSH_PORT || '22' }}
                  username: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.PROD_SSH_KEY }} # Action saves to ~/.ssh/deploy_key
                  project-path: ~/rustassistant
                  git-pull: false
                  git-branch: main
                  docker-pull: false
                  docker-prune: false
                  pre-deploy-command: |
                      echo "ü§ñ Deploying RustAssistant to Raspberry Pi..."

                      # Handle git repository setup
                      if [ ! -d "~/rustassistant/.git" ]; then
                        if [ -d "~/rustassistant" ]; then
                          echo "üìÅ Directory exists but is not a git repo - initializing..."
                          cd ~/rustassistant
                          git init
                          git remote add origin https://github.com/${{ github.repository }}.git
                          git fetch origin
                          git checkout -f main
                          git branch --set-upstream-to=origin/main main
                        else
                          echo "üì• First deployment - cloning repository..."
                          mkdir -p ~
                          git clone https://github.com/${{ github.repository }}.git ~/rustassistant
                          cd ~/rustassistant
                          git checkout main
                        fi
                      else
                        cd ~/rustassistant
                        echo "üì• Pulling latest changes..."
                        git fetch origin
                        git checkout main
                        git pull origin main
                      fi

                      # Ensure run.sh is executable
                      chmod +x ./run.sh 2>/dev/null || true

                      # Create .env file from template if it exists
                      if [ -f "deploy/env.template" ]; then
                        echo "üìù Creating .env from template..."
                        cp deploy/env.template .env
                        chmod 600 .env
                        echo "‚úÖ Created .env file"
                      elif [ ! -f ".env" ]; then
                        echo "üìù Creating default .env..."
                        cat > .env <<EOF
                      # RustAssistant Environment Configuration
                      RUST_LOG=info
                      EOF
                        chmod 600 .env
                        echo "‚úÖ Created default .env file"
                      else
                        echo "‚úÖ Using existing .env file"
                      fi

                  deploy-command: |
                      cd ~/rustassistant

                      # Deploy using run.sh to pull images and restart services
                      if [ -x "./run.sh" ]; then
                        echo "üê≥ Stopping existing services..."
                        ./run.sh stop 2>/dev/null || true
                        echo "üê≥ Pulling latest ARM64 images from Docker Hub..."
                        ./run.sh start
                      else
                        echo "‚ö†Ô∏è run.sh not found, using docker compose directly"
                        docker compose -f docker-compose.prod.yml pull --ignore-pull-failures
                        docker compose -f docker-compose.prod.yml up -d --remove-orphans
                      fi

                  post-deploy-command: |
                      cd ~/rustassistant

                      echo ""
                      echo "üìä Checking container health..."
                      docker compose -f docker-compose.prod.yml ps 2>/dev/null || docker ps --format "table {{.Names}}\t{{.Status}}"

                      echo ""
                      echo "üìä Storage usage:"
                      df -h / | grep -v Filesystem
                      docker system df

                      # Prune old images to save space on Raspberry Pi
                      echo ""
                      echo "üßπ Pruning unused Docker resources..."
                      docker system prune -f --volumes 2>/dev/null || true

                      echo ""
                      echo "üéØ Architecture information:"
                      uname -m
                      docker info --format '{{.Architecture}}'

                      echo ""
                      echo "‚úÖ RustAssistant deployment complete!"

            - name: üîç Verify deployment
              env:
                  PROD_SSH_USER: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  PROD_SSH_PORT: ${{ secrets.PROD_SSH_PORT || '22' }}
                  PI_HOST: ${{ secrets.PROD_TAILSCALE_IP }}
              run: |
                  echo "üìã Checking container logs..."

                  ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                      -p ${PROD_SSH_PORT} -i ~/.ssh/deploy_key \
                      ${PROD_SSH_USER}@${PI_HOST} \
                      "cd ~/rustassistant && docker compose -f docker-compose.prod.yml logs --tail=20" || true

            - name: ‚úÖ Notify deployment success
              if: success()
              continue-on-error: true
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_ACTIONS }}
                  title: "üöÄ Deployment Successful"
                  description: "RustAssistant deployed to Raspberry Pi"
                  status: success
                  fields: '[{"name": "Platform", "value": "ü•ß Raspberry Pi (ARM64)", "inline": true}, {"name": "Branch", "value": "${{ github.ref_name }}", "inline": true}, {"name": "Network", "value": "üîí Tailscale VPN", "inline": true}]'

            - name: ‚ùå Notify deployment failed
              if: failure()
              continue-on-error: true
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_ACTIONS }}
                  title: "‚ùå Deployment Failed"
                  description: "Failed to deploy to Raspberry Pi"
                  status: failure
                  fields: '[{"name": "Error", "value": "Check SSH connection and Tailscale setup", "inline": false}, {"name": "Logs", "value": "[View Workflow](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})", "inline": false}]'
